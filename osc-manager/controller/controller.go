package controller

import (
	"errors"
	"fmt"
	"log"
	"reflect"

	openapi "github.com/leonwanghui/osc-serverless/autogenerated/go-model"
	"github.com/leonwanghui/osc-serverless/osc-manager/providers"
	_ "github.com/leonwanghui/osc-serverless/osc-manager/providers/huaweicloud"
)

func NewController() *controller {

	return &controller{
		computeResourceMap: make(map[string]computeResourceHandler),
		storageResourceMap: make(map[string]storageResourceHandler),
		networkResourceMap: make(map[string]networkResourceHandler),
	}
}

type controller struct {
	computeResourceMap map[string]computeResourceHandler
	storageResourceMap map[string]storageResourceHandler
	networkResourceMap map[string]networkResourceHandler
}

type computeResourceHandler struct {
	crId       string
	getFunc    func(crName string) (*openapi.ComputeResourceSpec, error)
	deleteFunc func(crName string) error
}

type storageResourceHandler struct {
	srId       string
	getFunc    func(srName string) (*openapi.StorageResourceSpec, error)
	deleteFunc func(srName string) error
}

type networkResourceHandler struct {
	nrId       string
	getFunc    func(nrName string) (*openapi.NetworkResourceSpec, error)
	deleteFunc func(nrName string) error
}

func (c *controller) CreateComputeResource(req *openapi.ComputeResourceCreateRequest) (
	*openapi.ComputeResourceSpec, error) {
	// Initialize cloud provider
	cp := providers.NewCloudProvider(req.CloudProvider.Name)
	// If compute resource already exists, just return the existing
	// compute resource directly.
	if handler, ok := c.computeResourceMap[req.Name]; ok {
		log.Printf("compute resource %s already exists, return it directly\n",
			req.Name)
		return handler.getFunc(handler.crId)
	}

	computeHandler := computeResourceHandler{}
	compute, err := func(handler *computeResourceHandler) (*openapi.ComputeResourceSpec, error) {
		if !reflect.DeepEqual(req.CloudServerRequestFragment, openapi.CloudServerRequestFragment{}) {
			server, err := cp.CreateCloudServer(req)
			if err != nil {
				return nil, err
			}
			handler.crId = server.Id
			handler.getFunc = cp.GetCloudServer
			handler.deleteFunc = cp.DeleteCloudServer
			return server, nil
		}
		if !reflect.DeepEqual(req.PhysicalServerRequestFragment, openapi.CloudServerRequestFragment{}) {
			server, err := cp.CreatePhysicalServer(req)
			if err != nil {
				return nil, err
			}
			handler.crId = server.Id
			handler.getFunc = cp.GetPhysicalServer
			handler.deleteFunc = cp.DeletePhysicalServer
			return server, nil
		}
		emptyMap := make(map[string]interface{})
		if !reflect.DeepEqual(req.PodRequestFragment, emptyMap) {
			pod, err := cp.CreatePod(req)
			if err != nil {
				return nil, err
			}
			handler.crId = pod.Id
			handler.getFunc = cp.GetPod
			handler.deleteFunc = cp.DeletePod
			return pod, nil
		}
		return nil, errors.New("compute request is not valid!")
	}(&computeHandler)
	if err != nil {
		log.Println("failed to create compute resource in controller:", err)
		return nil, err
	}

	c.computeResourceMap[req.Name] = computeHandler
	return compute, nil
}

func (c *controller) GetComputeResource(crName string) (
	*openapi.ComputeResourceSpec, error) {

	handler, ok := c.computeResourceMap[crName]
	if !ok {
		errMsg := fmt.Errorf("ERROR: cannot find %s in computeResourceMap", crName)
		log.Println(errMsg)
		return nil, errMsg
	}

	return handler.getFunc(handler.crId)
}

func (c *controller) DeleteComputeResource(crName string) error {

	handler, ok := c.computeResourceMap[crName]
	if !ok {
		log.Printf("WARNNING: cannot find %s in computeResourceMap\n", crName)
		return nil
	}
	if err := handler.deleteFunc(handler.crId); err != nil {
		log.Println("failed to delete compute resource in controller")
		return err
	}

	delete(c.computeResourceMap, crName)
	return nil
}

func (c *controller) CreateStorageResource(req *openapi.StorageResourceCreateRequest) (
	*openapi.StorageResourceSpec, error) {
	// Initialize cloud provider
	cp := providers.NewCloudProvider(req.CloudProvider.Name)
	// If storage resource already exists, just return the existing
	// storage resource directly.
	if handler, ok := c.storageResourceMap[req.Name]; ok {
		log.Printf("storage resource %s already exists, return it directly\n",
			req.Name)
		return handler.getFunc(handler.srId)
	}

	storageHandler := storageResourceHandler{}
	storage, err := func(handler *storageResourceHandler) (*openapi.StorageResourceSpec, error) {
		if !reflect.DeepEqual(req.BlockVolumeRequestFragment, openapi.BlockVolumeRequestFragment{}) {
			volume, err := cp.CreateBlockVolume(req)
			if err != nil {
				return nil, err
			}
			handler.srId = volume.Id
			handler.getFunc = cp.GetBlockVolume
			handler.deleteFunc = cp.DeleteBlockVolume
			return volume, nil
		}
		if !reflect.DeepEqual(req.FileShareRequestFragment, openapi.FileShareRequestFragment{}) {
			share, err := cp.CreateFileShare(req)
			if err != nil {
				return nil, err
			}
			handler.srId = share.Id
			handler.getFunc = cp.GetFileShare
			handler.deleteFunc = cp.DeleteFileShare
			return share, nil
		}
		if !reflect.DeepEqual(req.BackupRequestFragment, openapi.BackupRequestFragment{}) {
			backup, err := cp.CreateBackup(req)
			if err != nil {
				return nil, err
			}
			handler.srId = backup.Id
			handler.getFunc = cp.GetBackup
			handler.deleteFunc = cp.DeleteBackup
			return backup, nil
		}
		return nil, errors.New("storage request is not valid!")
	}(&storageHandler)
	if err != nil {
		log.Println("failed to create storage resource in controller:", err)
		return nil, err
	}

	c.storageResourceMap[req.Name] = storageHandler
	return storage, nil
}

func (c *controller) GetStorageResource(srName string) (
	*openapi.StorageResourceSpec, error) {

	handler, ok := c.storageResourceMap[srName]
	if !ok {
		errMsg := fmt.Errorf("ERROR: cannot find %s in storageResourceMap", srName)
		log.Println(errMsg)
		return nil, errMsg
	}

	return handler.getFunc(handler.srId)

}

func (c *controller) DeleteStorageResource(srName string) error {

	handler, ok := c.storageResourceMap[srName]
	if !ok {
		log.Printf("WARNNING: cannot find %s in storageResourceMap\n", srName)
		return nil
	}
	if err := handler.deleteFunc(handler.srId); err != nil {
		log.Println("failed to delete storage resource in controller:", err)
		return err
	}

	delete(c.storageResourceMap, srName)
	return nil
}

func (c *controller) CreateNetworkResource(req *openapi.NetworkResourceCreateRequest) (
	*openapi.NetworkResourceSpec, error) {
	// Initialize cloud provider
	cp := providers.NewCloudProvider(req.CloudProvider.Name)
	// If network resource already exists, just return the existing
	// network resource directly.
	if handler, ok := c.networkResourceMap[req.Name]; ok {
		log.Printf("network resource %s already exists, return it directly\n",
			req.Name)
		return handler.getFunc(handler.nrId)
	}

	networkHandler := networkResourceHandler{}
	network, err := func(handler *networkResourceHandler) (*openapi.NetworkResourceSpec, error) {
		if !reflect.DeepEqual(req.VpcRequestFragment, openapi.VpcRequestFragment{}) {
			vpc, err := cp.CreateVPC(req)
			if err != nil {
				return nil, err
			}
			handler.nrId = vpc.Id
			handler.getFunc = cp.GetVPC
			handler.deleteFunc = cp.DeleteVPC
			return vpc, nil
		}
		if !reflect.DeepEqual(req.SubnetRequestFragment, openapi.SubnetRequestFragment{}) {
			subnet, err := cp.CreateSubnet(req)
			if err != nil {
				return nil, err
			}
			handler.nrId = subnet.Id
			handler.getFunc = cp.GetSubnet
			handler.deleteFunc = cp.DeleteSubnet
			return subnet, nil
		}
		if !reflect.DeepEqual(req.PublicipRequestFragment, openapi.PublicipRequestFragment{}) {
			fip, err := cp.CreateFloatingIP(req)
			if err != nil {
				return nil, err
			}
			handler.nrId = fip.Id
			handler.getFunc = cp.GetFloatingIP
			handler.deleteFunc = cp.DeleteFloatingIP
			return fip, nil
		}
		return nil, errors.New("network request is not valid!")
	}(&networkHandler)
	if err != nil {
		log.Println("failed to create network resource in controller:", err)
		return nil, err
	}

	c.networkResourceMap[req.Name] = networkHandler
	return network, nil
}

func (c *controller) GetNetworkResource(nrName string) (
	*openapi.NetworkResourceSpec, error) {

	handler, ok := c.networkResourceMap[nrName]
	if !ok {
		errMsg := fmt.Errorf("ERROR: cannot find %s in networkResourceMap", nrName)
		log.Println(errMsg)
		return nil, errMsg
	}

	return handler.getFunc(handler.nrId)
}

func (c *controller) DeleteNetworkResource(nrName string) error {

	handler, ok := c.networkResourceMap[nrName]
	if !ok {
		log.Printf("WARNNING: cannot find %s in networkResourceMap\n", nrName)
		return nil
	}
	if err := handler.deleteFunc(handler.nrId); err != nil {
		log.Println("failed to delete network resource in controller:", err)
		return err
	}

	delete(c.networkResourceMap, nrName)
	return nil
}
